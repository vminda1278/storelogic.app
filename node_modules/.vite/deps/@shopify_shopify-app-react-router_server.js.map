{
  "version": 3,
  "sources": ["../../adapters/web-api/adapter.ts", "../../adapters/web-api/index.ts", "../../@shopify/src/server/boundary/headers.ts", "../../@shopify/src/server/boundary/error.tsx", "../../@shopify/src/server/boundary/index.ts", "../../@shopify/src/server/version.ts", "../../@shopify/src/server/authenticate/webhooks/register.ts", "../../@shopify/src/server/authenticate/helpers/ensure-cors-headers.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-bounce-page.ts", "../../@shopify/src/server/authenticate/helpers/respond-to-invalid-session-token.ts", "../../@shopify/src/server/authenticate/helpers/get-shop-from-request.ts", "../../@shopify/src/server/authenticate/helpers/validate-session-token.ts", "../../@shopify/src/server/authenticate/helpers/get-session-token-header.ts", "../../@shopify/src/server/authenticate/helpers/reject-bot-request.ts", "../../@shopify/src/server/authenticate/helpers/respond-to-options-request.ts", "../../@shopify/src/server/authenticate/helpers/invalidate-access-token.ts", "../../@shopify/src/server/authenticate/admin/billing/cancel.ts", "../../@shopify/src/server/authenticate/admin/billing/require.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-with-app-bridge-headers.ts", "../../@shopify/src/server/authenticate/admin/billing/helpers.ts", "../../@shopify/src/server/authenticate/admin/billing/request.ts", "../../@shopify/src/server/authenticate/admin/billing/check.ts", "../../@shopify/src/server/authenticate/admin/billing/create-usage-record.ts", "../../@shopify/src/server/authenticate/admin/billing/update-usage-subscription-capped-amount.ts", "../../@shopify/src/server/clients/admin/graphql.ts", "../../@shopify/src/server/clients/admin/factory.ts", "../../@shopify/src/server/authenticate/admin/helpers/create-admin-api-context.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-shopify-or-app-root.ts", "../../@shopify/src/server/authenticate/admin/helpers/ensure-app-is-embedded-if-required.ts", "../../@shopify/src/server/authenticate/admin/helpers/ensure-session-token-search-param-if-required.ts", "../../@shopify/src/server/authenticate/helpers/add-response-headers.ts", "../../@shopify/src/server/authenticate/admin/helpers/validate-redirect-url.ts", "../../@shopify/src/server/authenticate/admin/helpers/render-app-bridge.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect.ts", "../../@shopify/src/server/authenticate/admin/helpers/validate-shop-and-host-params.ts", "../../@shopify/src/server/authenticate/admin/helpers/redirect-to-install-page.ts", "../../@shopify/src/server/authenticate/admin/scope/client/fetch-scopes-details.ts", "../../@shopify/src/server/authenticate/admin/scope/request.ts", "../../@shopify/src/server/authenticate/admin/scope/query.ts", "../../@shopify/src/server/authenticate/admin/scope/client/revoke-scopes.ts", "../../@shopify/src/server/authenticate/admin/scope/revoke.ts", "../../@shopify/src/server/authenticate/admin/scope/factory.ts", "../../@shopify/src/server/authenticate/admin/authenticate.ts", "../../@shopify/src/server/authenticate/admin/helpers/handle-client-error.ts", "../../@shopify/src/server/authenticate/helpers/create-or-load-offline-session.ts", "../../@shopify/src/server/authenticate/webhooks/authenticate.ts", "../../@shopify/src/server/override-logger.ts", "../../@shopify/src/server/authenticate/login/login.ts", "../../@shopify/src/server/errors.ts", "../../@shopify/src/server/unauthenticated/admin/factory.ts", "../../@shopify/src/server/authenticate/public/extension/authenticate.ts", "../../@shopify/src/server/authenticate/public/checkout/authenticate.ts", "../../@shopify/src/server/clients/storefront/factory.ts", "../../@shopify/src/server/authenticate/public/appProxy/authenticate.ts", "../../@shopify/src/server/authenticate/public/customer-account/authenticate.ts", "../../@shopify/src/server/authenticate/public/factory.ts", "../../@shopify/src/server/unauthenticated/storefront/factory.ts", "../../@shopify/src/server/authenticate/admin/helpers/trigger-after-auth-hook.ts", "../../@shopify/src/server/authenticate/admin/strategies/token-exchange.ts", "../../@shopify/src/server/authenticate/admin/strategies/merchant-custom-app.ts", "../../@shopify/src/server/authenticate/helpers/idempotent-promise-handler.ts", "../../@shopify/src/server/authenticate/flow/authenticate.ts", "../../@shopify/src/server/authenticate/fulfillment-service/authenticate.ts", "../../@shopify/src/server/authenticate/pos/authenticate.ts", "../../@shopify/src/server/shopify-app.ts", "../../@shopify/src/server/index.ts"],
  "sourcesContent": ["import type {\n  Headers as ShopifyHeaders,\n  AdapterArgs,\n  NormalizedResponse,\n  NormalizedRequest,\n} from '../../runtime';\nimport {addHeader, flatHeaders} from '../../runtime';\n\ninterface WebApiAdapterArgs extends AdapterArgs {\n  rawRequest: Request;\n}\n\nexport async function webApiConvertRequest(\n  adapterArgs: WebApiAdapterArgs,\n): Promise<NormalizedRequest> {\n  const request = adapterArgs.rawRequest;\n  const headers = {};\n  for (const [key, value] of request.headers.entries()) {\n    addHeader(headers, key, value);\n  }\n\n  return {\n    headers,\n    method: request.method ?? 'GET',\n    url: new URL(request.url).toString(),\n  };\n}\n\nexport async function webApiConvertHeaders(\n  headers: ShopifyHeaders,\n  _adapterArgs: WebApiAdapterArgs,\n): Promise<Headers> {\n  const remixHeaders = new Headers();\n  flatHeaders(headers ?? {}).forEach(([key, value]) =>\n    remixHeaders.append(key, value),\n  );\n  return Promise.resolve(remixHeaders);\n}\n\nexport async function webApiConvertResponse(\n  resp: NormalizedResponse,\n  adapterArgs: WebApiAdapterArgs,\n): Promise<Response> {\n  return new Response(resp.body, {\n    status: resp.statusCode,\n    statusText: resp.statusText,\n    headers: await webApiConvertHeaders(resp.headers ?? {}, adapterArgs),\n  });\n}\n\nexport function webApiRuntimeString(): string {\n  return 'Web API';\n}\n", "import {\n  setAbstractFetchFunc,\n  setAbstractConvertRequestFunc,\n  setAbstractConvertResponseFunc,\n  setAbstractConvertHeadersFunc,\n  setAbstractRuntimeString,\n} from '../../runtime';\n\nimport {\n  webApiConvertHeaders,\n  webApiConvertRequest,\n  webApiConvertResponse,\n  webApiRuntimeString,\n} from './adapter';\n\nsetAbstractFetchFunc(fetch);\nsetAbstractConvertRequestFunc(webApiConvertRequest);\nsetAbstractConvertResponseFunc(webApiConvertResponse);\nsetAbstractConvertHeadersFunc(webApiConvertHeaders);\nsetAbstractRuntimeString(webApiRuntimeString);\n", "import {HeadersArgs} from 'react-router';\n\nexport function headersBoundary(headers: HeadersArgs): Headers {\n  const {parentHeaders, loaderHeaders, actionHeaders, errorHeaders} = headers;\n\n  if (errorHeaders && Array.from(errorHeaders.entries()).length > 0) {\n    return errorHeaders;\n  }\n\n  return new Headers([\n    ...(parentHeaders ? Array.from(parentHeaders.entries()) : []),\n    ...(loaderHeaders ? Array.from(loaderHeaders.entries()) : []),\n    ...(actionHeaders ? Array.from(actionHeaders.entries()) : []),\n  ]);\n}\n", "export function errorBoundary(error: any) {\n  if (\n    error.constructor.name === 'ErrorResponse' ||\n    error.constructor.name === 'ErrorResponseImpl'\n  ) {\n    return (\n      <div\n        dangerouslySetInnerHTML={{__html: error.data || 'Handling response'}}\n      />\n    );\n  }\n\n  throw error;\n}\n", "import {headersBoundary} from './headers';\nimport {errorBoundary} from './error';\n\n/**\n * A collection of functions that handle the necessary code for error boundaries in routes using authenticate.admin.\n */\nexport const boundary = {\n  /**\n   * A function that handles errors or thrown responses.\n   *\n   * @example\n   * <caption>Catching errors in a route</caption>\n   * ```ts\n   * // /app/routes/admin/widgets.ts\n   * import { boundary } from \"@shopify/shopify-app-react-router/server\";\n   *\n   * export function ErrorBoundary() {\n   *   return boundary.error(useRouteError());\n   * }\n   * ```\n   */\n  error: errorBoundary,\n\n  /**\n   * A function that sets the appropriate document response headers.\n   *\n   * @example\n   * <caption>Catching errors in a route</caption>\n   * ```ts\n   * // /app/routes/admin/widgets.ts\n   * import { boundary } from \"@shopify/shopify-app-react-router/server\";\n   *\n   * export const headers = (headersArgs) => {\n   *   return boundary.headers(headersArgs);\n   * };\n   * ```\n   */\n  headers: headersBoundary,\n};\n", "export const SHOPIFY_REACT_ROUTER_LIBRARY_VERSION = '1.0.1';\n", "import type {BasicParams} from '../../types';\n\nimport type {RegisterWebhooksOptions} from './types';\n\nexport function registerWebhooksFactory({api, logger}: BasicParams) {\n  return async function registerWebhooks({session}: RegisterWebhooksOptions) {\n    return api.webhooks\n      .register({session})\n      .then((response) => {\n        Object.entries(response).forEach(([topic, topicResults]) => {\n          topicResults.forEach(({success, ...rest}) => {\n            if (success) {\n              logger.debug('Registered webhook', {\n                topic,\n                shop: session.shop,\n                operation: rest.operation,\n              });\n            } else {\n              logger.error('Failed to register webhook', {\n                topic,\n                shop: session.shop,\n                result: JSON.stringify(rest.result),\n              });\n            }\n          });\n        });\n\n        return response;\n      })\n      .catch((error) => {\n        const graphQLErrors: {extensions: {code?: string}}[] =\n          error.body?.errors?.graphQLErrors || [];\n\n        const throttled = graphQLErrors.find(\n          ({extensions: {code}}) => code === 'THROTTLED',\n        );\n\n        if (throttled) {\n          logger.error('Failed to register webhooks', {\n            shop: session.shop,\n            error: JSON.stringify(error),\n          });\n        } else {\n          throw error;\n        }\n      });\n  };\n}\n", "import {BasicParams} from '../../types';\nimport {REAUTH_URL_HEADER} from '../const';\n\nexport interface EnsureCORSFunction {\n  (response: Response): Response;\n}\n\nexport function ensureCORSHeadersFactory(\n  params: BasicParams,\n  request: Request,\n  corsHeaders: string[] = [],\n): EnsureCORSFunction {\n  const {logger, config} = params;\n\n  return function ensureCORSHeaders(response) {\n    const origin = request.headers.get('Origin');\n    if (origin && origin !== config.appUrl) {\n      logger.debug(\n        'Request comes from a different origin, adding CORS headers',\n      );\n\n      const corsHeadersSet = new Set([\n        'Authorization',\n        'Content-Type',\n        ...corsHeaders,\n      ]);\n\n      response.headers.set('Access-Control-Allow-Origin', '*');\n      response.headers.set(\n        'Access-Control-Allow-Headers',\n        [...corsHeadersSet].join(', '),\n      );\n      response.headers.set('Access-Control-Expose-Headers', REAUTH_URL_HEADER);\n    }\n\n    return response;\n  };\n}\n", "import {redirect} from 'react-router';\n\nimport {BasicParams} from '../../../types';\n\nexport const redirectToBouncePage = (params: BasicParams, url: URL): never => {\n  const {config} = params;\n\n  // Make sure we always point to the configured app URL so it also works behind reverse proxies (that alter the Host\n  // header).\n  const searchParams = url.searchParams;\n  searchParams.delete('id_token');\n  searchParams.set(\n    'shopify-reload',\n    `${config.appUrl}${url.pathname}?${searchParams.toString()}`,\n  );\n\n  // eslint-disable-next-line no-warning-comments\n  // TODO Make sure this works on chrome without a tunnel (weird HTTPS redirect issue)\n  // https://github.com/orgs/Shopify/projects/6899/views/1?pane=issue&itemId=28376650\n  throw redirect(\n    `${config.auth.patchSessionTokenPath}?${searchParams.toString()}`,\n  );\n};\n", "import {redirectToBouncePage} from '../admin/helpers/redirect-to-bounce-page';\nimport {RETRY_INVALID_SESSION_HEADER} from '../const';\nimport {BasicParams} from '../../types';\n\ninterface RespondToInvalidSessionTokenParams {\n  params: BasicParams;\n  request: Request;\n  retryRequest?: boolean;\n}\n\nexport function respondToInvalidSessionToken({\n  params,\n  request,\n  retryRequest = false,\n}: RespondToInvalidSessionTokenParams) {\n  const {api, logger, config} = params;\n\n  const isDocumentRequest = !request.headers.get('authorization');\n  if (isDocumentRequest) {\n    return redirectToBouncePage({api, logger, config}, new URL(request.url));\n  }\n\n  throw new Response(undefined, {\n    status: 401,\n    statusText: 'Unauthorized',\n    headers: retryRequest ? RETRY_INVALID_SESSION_HEADER : {},\n  });\n}\n", "export function getShopFromRequest(request: Request) {\n  const url = new URL(request.url);\n  return url.searchParams.get('shop')!;\n}\n", "import {JwtPayload} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\n\nimport {respondToInvalidSessionToken} from './respond-to-invalid-session-token';\nimport {getShopFromRequest} from './get-shop-from-request';\n\ninterface ValidateSessionTokenOptions {\n  checkAudience?: boolean;\n  retryRequest?: boolean;\n}\n\nexport async function validateSessionToken(\n  params: BasicParams,\n  request: Request,\n  token: string,\n  {checkAudience = true, retryRequest = true}: ValidateSessionTokenOptions = {},\n): Promise<JwtPayload> {\n  const {api, logger} = params;\n  const shop = getShopFromRequest(request);\n  logger.debug('Validating session token', {shop});\n\n  try {\n    const payload = await api.session.decodeSessionToken(token, {\n      checkAudience,\n    });\n    logger.debug('Session token is valid - validated', {\n      shop,\n      payload: JSON.stringify(payload),\n    });\n\n    return payload;\n  } catch (error) {\n    logger.debug(`Failed to validate session token: ${error.message}`, {\n      shop,\n    });\n\n    throw respondToInvalidSessionToken({params, request, retryRequest});\n  }\n}\n", "const SESSION_TOKEN_PARAM = 'id_token';\n\nexport function getSessionTokenHeader(request: Request): string | undefined {\n  return request.headers.get('authorization')?.replace('Bearer ', '');\n}\n\nexport function getSessionTokenFromUrlParam(request: Request): string | null {\n  const url = new URL(request.url);\n\n  return url.searchParams.get(SESSION_TOKEN_PARAM);\n}\n", "import {isbot} from 'isbot';\n\nimport type {BasicParams} from '../../types';\n\nconst SHOPIFY_POS_USER_AGENT = /Shopify POS\\//;\nconst SHOPIFY_MOBILE_USER_AGENT = /Shopify Mobile\\//;\n\nconst SHOPIFY_USER_AGENTS = [SHOPIFY_POS_USER_AGENT, SHOPIFY_MOBILE_USER_AGENT];\n\nexport function respondToBotRequest(\n  {logger}: BasicParams,\n  request: Request,\n): void | never {\n  const userAgent = request.headers.get('User-Agent') ?? '';\n\n  // We call isbot below to prevent good (self-identifying) bots from triggering auth requests, but there are some\n  // Shopify-specific cases we want to allow that are identified as bots by isbot.\n  if (SHOPIFY_USER_AGENTS.some((agent) => agent.test(userAgent))) {\n    logger.debug('Request is from a Shopify agent, allow');\n    return;\n  }\n\n  if (isbot(userAgent)) {\n    logger.debug('Request is from a bot, skipping auth');\n    throw new Response(undefined, {status: 410, statusText: 'Gone'});\n  }\n}\n", "import {BasicParams} from '../../types';\n\nimport {ensureCORSHeadersFactory} from './ensure-cors-headers';\n\nexport function respondToOptionsRequest(\n  params: BasicParams,\n  request: Request,\n  corsHeaders?: string[],\n) {\n  if (request.method === 'OPTIONS') {\n    const ensureCORSHeaders = ensureCORSHeadersFactory(\n      params,\n      request,\n      corsHeaders,\n    );\n\n    throw ensureCORSHeaders(\n      new Response(null, {\n        status: 204,\n        headers: {\n          'Access-Control-Max-Age': '7200',\n        },\n      }),\n    );\n  }\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\n\nexport async function invalidateAccessToken(\n  params: BasicParams,\n  session: Session,\n): Promise<void> {\n  const {logger, config} = params;\n\n  logger.debug(`Invalidating access token for session - ${session.id}`, {\n    shop: session.shop,\n  });\n\n  session.accessToken = undefined;\n  await config.sessionStorage!.storeSession(session);\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  invalidateAccessToken,\n  respondToInvalidSessionToken,\n} from '../../helpers';\n\nimport type {CancelBillingOptions} from './types';\n\nexport function cancelBillingFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function cancelBilling(options: CancelBillingOptions) {\n    const {api, logger} = params;\n\n    logger.debug('Cancelling billing', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.cancel({\n        session,\n        subscriptionId: options.subscriptionId,\n        isTest: options.isTest,\n        prorate: options.prorate,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, responding to invalid session', {\n          shop: session.shop,\n        });\n\n        await invalidateAccessToken(params, session);\n\n        throw respondToInvalidSessionToken({\n          params,\n          request,\n          retryRequest: true,\n        });\n      }\n      throw error;\n    }\n  };\n}\n", "import {\n  BillingCheckResponseObject,\n  HttpResponseError,\n  Session,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport type {AppConfigArg} from '../../../config-types';\nimport {\n  invalidateAccessToken,\n  respondToInvalidSessionToken,\n} from '../../helpers';\n\nimport type {RequireBillingOptions} from './types';\n\nexport function requireBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  const {api, logger} = params;\n\n  return async function requireBilling(options: RequireBillingOptions<Config>) {\n    const logContext = {\n      shop: session.shop,\n      plans: options.plans,\n      isTest: options.isTest,\n    };\n\n    logger.debug('Checking billing for the shop', logContext);\n\n    let data: BillingCheckResponseObject;\n    try {\n      data = await api.billing.check({\n        session,\n        plans: options.plans as string[],\n        isTest: options.isTest,\n        returnObject: true,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug(\n          'API token was invalid, responding to invalid session',\n          logContext,\n        );\n\n        await invalidateAccessToken(params, session);\n\n        throw respondToInvalidSessionToken({\n          params,\n          request,\n          retryRequest: true,\n        });\n      }\n      throw error;\n    }\n\n    if (!data.hasActivePayment) {\n      logger.debug('Billing check failed', logContext);\n      throw await options.onFailure(new Error('Billing check failed'));\n    }\n\n    logger.debug('Billing check succeeded', logContext);\n\n    return data;\n  };\n}\n", "import {REAUTH_URL_HEADER} from '../../const';\n\nexport function redirectWithAppBridgeHeaders(redirectUri: string): never {\n  throw new Response(undefined, {\n    status: 401,\n    statusText: 'Unauthorized',\n    headers: getAppBridgeHeaders(redirectUri),\n  });\n}\n\nexport function getAppBridgeHeaders(url: string) {\n  return new Headers({[REAUTH_URL_HEADER]: url});\n}\n", "import {redirect} from 'react-router';\n\nimport {BasicParams} from '../../../types';\nimport {getAppBridgeHeaders} from '../helpers';\n\nexport function redirectOutOfApp(\n  params: BasicParams,\n  request: Request,\n  url: string,\n  shop: string,\n): never {\n  const {config, logger} = params;\n\n  logger.debug('Redirecting out of app', {shop, url});\n\n  const requestUrl = new URL(request.url);\n  const isEmbeddedRequest = requestUrl.searchParams.get('embedded') === '1';\n  const isXhrRequest = request.headers.get('authorization');\n\n  if (isXhrRequest) {\n    throw new Response(undefined, {\n      status: 401,\n      statusText: 'Unauthorized',\n      headers: getAppBridgeHeaders(url),\n    });\n  } else if (isEmbeddedRequest) {\n    const params = new URLSearchParams({\n      shop,\n      host: requestUrl.searchParams.get('host')!,\n      exitIframe: url,\n    });\n\n    throw redirect(`${config.auth.exitIframePath}?${params.toString()}`);\n  } else {\n    // This will only ever happen for non-embedded apps, because the authenticator will stop before reaching this point\n    throw redirect(url);\n  }\n}\n", "import {\n  BillingRequestResponseObject,\n  HttpResponseError,\n  Session,\n} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {\n  invalidateAccessToken,\n  respondToInvalidSessionToken,\n} from '../../helpers';\n\nimport {redirectOutOfApp} from './helpers';\nimport type {RequestBillingOptions} from './types';\n\nexport function requestBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function requestBilling({\n    plan,\n    isTest,\n    returnUrl,\n    ...overrides\n  }: RequestBillingOptions<Config>): Promise<never> {\n    const {api, logger} = params;\n\n    logger.info('Requesting billing', {\n      shop: session.shop,\n      plan,\n      isTest,\n      returnUrl,\n    });\n\n    let result: BillingRequestResponseObject;\n    try {\n      result = await api.billing.request({\n        plan: plan as string,\n        session,\n        isTest,\n        returnUrl,\n        returnObject: true,\n        ...overrides,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, responding to invalid session', {\n          shop: session.shop,\n        });\n\n        await invalidateAccessToken(params, session);\n\n        throw respondToInvalidSessionToken({\n          params,\n          request,\n          retryRequest: true,\n        });\n      }\n      throw error;\n    }\n\n    throw redirectOutOfApp(\n      params,\n      request,\n      result.confirmationUrl,\n      session.shop,\n    );\n  };\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport type {AppConfigArg} from '../../../config-types';\nimport {\n  invalidateAccessToken,\n  respondToInvalidSessionToken,\n} from '../../helpers';\n\nimport type {CheckBillingOptions} from './types';\n\nexport function checkBillingFactory<Config extends AppConfigArg>(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function checkBilling(\n    options: CheckBillingOptions<Config> = {},\n  ) {\n    const {api, logger} = params;\n\n    logger.debug('Checking billing plans', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.check({\n        session,\n        plans: options.plans as string[],\n        isTest: options.isTest,\n        returnObject: true,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, responding to invalid session', {\n          shop: session.shop,\n        });\n\n        await invalidateAccessToken(params, session);\n\n        throw respondToInvalidSessionToken({\n          params,\n          request,\n          retryRequest: true,\n        });\n      }\n      throw error;\n    }\n  };\n}\n", "import {HttpResponseError, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  invalidateAccessToken,\n  respondToInvalidSessionToken,\n} from '../../helpers';\n\nimport type {CreateUsageRecordOptions} from './types';\n\nexport function createUsageRecordFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function createUsageRecord(options: CreateUsageRecordOptions) {\n    const {api, logger} = params;\n\n    logger.debug('Create usage record', {shop: session.shop, ...options});\n\n    try {\n      return await api.billing.createUsageRecord({\n        ...options,\n        session,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, responding to invalid session', {\n          shop: session.shop,\n        });\n\n        await invalidateAccessToken(params, session);\n\n        throw respondToInvalidSessionToken({\n          params,\n          request,\n          retryRequest: true,\n        });\n      }\n      throw error;\n    }\n  };\n}\n", "import {\n  HttpResponseError,\n  Session,\n  UpdateCappedAmountConfirmation,\n} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  invalidateAccessToken,\n  respondToInvalidSessionToken,\n} from '../../helpers';\n\nimport {UpdateUsageCappedAmountOptions} from './types';\nimport {redirectOutOfApp} from './helpers';\n\nexport function updateUsageCappedAmountFactory(\n  params: BasicParams,\n  request: Request,\n  session: Session,\n) {\n  return async function updateUsageCappedAmount(\n    options: UpdateUsageCappedAmountOptions,\n  ): Promise<never> {\n    const {api, logger} = params;\n\n    logger.debug('Updating usage subscription capped amount', {\n      shop: session.shop,\n      ...options,\n    });\n\n    let result: UpdateCappedAmountConfirmation;\n    try {\n      result = await api.billing.updateUsageCappedAmount({\n        session,\n        subscriptionLineItemId: options.subscriptionLineItemId,\n        cappedAmount: options.cappedAmount,\n      });\n    } catch (error) {\n      if (error instanceof HttpResponseError && error.response.code === 401) {\n        logger.debug('API token was invalid, responding to invalid session', {\n          shop: session.shop,\n        });\n\n        await invalidateAccessToken(params, session);\n\n        throw respondToInvalidSessionToken({\n          params,\n          request,\n          retryRequest: true,\n        });\n      }\n      throw error;\n    }\n\n    throw redirectOutOfApp(\n      params,\n      request,\n      result.confirmationUrl,\n      session.shop,\n    );\n  };\n}\n", "import {AdminOperations} from '@shopify/admin-api-client';\n\nimport {GraphQLClient} from '../types';\n\nimport {AdminClientOptions} from './types';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: This is actually just a call through to the Shopify API client, but with a different API. We should eventually\n// move this over to the library layer. While doing that, we should also allow the apiVersion to be passed into the REST\n// client request calls.\nexport function graphqlClientFactory({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): GraphQLClient<AdminOperations> {\n  return async function query(operation, options) {\n    const client = new params.api.clients.Graphql({\n      session,\n      apiVersion: options?.apiVersion,\n    });\n\n    try {\n      // We convert the incoming response to a Response object to bring this client closer to the React Router client.\n      const apiResponse = await client.request(operation, {\n        variables: options?.variables,\n        retries: options?.tries ? options.tries - 1 : 0,\n        headers: options?.headers,\n        signal: options?.signal,\n      });\n\n      return new Response(JSON.stringify(apiResponse));\n    } catch (error) {\n      if (handleClientError) {\n        throw await handleClientError({error, params, session});\n      }\n\n      throw error;\n    }\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../types';\n\nimport {graphqlClientFactory} from './graphql';\nimport type {AdminApiContext} from './types';\n\ninterface AdminClientOptions {\n  params: BasicParams;\n  session: Session;\n  handleClientError?: (error: any) => Promise<void>;\n}\n\nexport function adminClientFactory({\n  params,\n  handleClientError,\n  session,\n}: AdminClientOptions): AdminApiContext {\n  return {\n    graphql: graphqlClientFactory({params, session, handleClientError}),\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {\n  AdminApiContext,\n  HandleAdminClientError,\n  adminClientFactory,\n} from '../../../clients/admin';\n\nexport function createAdminApiContext(\n  session: Session,\n  params: BasicParams,\n  handleClientError: HandleAdminClientError,\n): AdminApiContext {\n  return adminClientFactory({\n    session,\n    params,\n    handleClientError,\n  });\n}\n", "import {redirect} from 'react-router';\n\nimport type {BasicParams} from '../../../types';\nimport {AppDistribution} from '../../../types';\n\nexport async function redirectToShopifyOrAppRoot(\n  request: Request,\n  params: BasicParams,\n  responseHeaders?: Headers,\n): Promise<never> {\n  const {api, config} = params;\n  const url = new URL(request.url);\n\n  const host = api.utils.sanitizeHost(url.searchParams.get('host')!)!;\n  const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!)!;\n\n  let redirectUrl;\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    redirectUrl = `/?shop=${shop}&host=${encodeURIComponent(host)}`;\n  } else {\n    redirectUrl = await api.auth.getEmbeddedAppUrl({rawRequest: request});\n  }\n\n  throw redirect(redirectUrl, {headers: responseHeaders});\n}\n", "import {BasicParams, AppDistribution} from '../../../types';\n\nimport {redirectToShopifyOrAppRoot} from './redirect-to-shopify-or-app-root';\n\nexport const ensureAppIsEmbeddedIfRequired = async (\n  params: BasicParams,\n  request: Request,\n) => {\n  const {api, logger, config} = params;\n  const url = new URL(request.url);\n\n  const shop = url.searchParams.get('shop')!;\n\n  if (\n    config.distribution !== AppDistribution.ShopifyAdmin &&\n    url.searchParams.get('embedded') !== '1'\n  ) {\n    logger.debug('App is not embedded, redirecting to Shopify', {shop});\n    await redirectToShopifyOrAppRoot(request, {api, logger, config});\n  }\n};\n", "import {BasicParams, AppDistribution} from '../../../types';\n\nimport {redirectToBouncePage} from './redirect-to-bounce-page';\n\nconst SESSION_TOKEN_PARAM = 'id_token';\n\nexport const ensureSessionTokenSearchParamIfRequired = async (\n  params: BasicParams,\n  request: Request,\n) => {\n  const {logger, config} = params;\n  const url = new URL(request.url);\n\n  const shop = url.searchParams.get('shop')!;\n  const searchParamSessionToken = url.searchParams.get(SESSION_TOKEN_PARAM);\n  const isEmbedded = url.searchParams.get('embedded') === '1';\n\n  if (\n    config.distribution !== AppDistribution.ShopifyAdmin &&\n    isEmbedded &&\n    !searchParamSessionToken\n  ) {\n    logger.debug(\n      'Missing session token in search params, going to bounce page',\n      {shop},\n    );\n    redirectToBouncePage(params, url);\n  }\n};\n", "import type {BasicParams} from '../../types';\nimport {AppDistribution} from '../../types';\nimport {APP_BRIDGE_URL, CDN_URL, POLARIS_URL} from '../const';\n\nexport type AddDocumentResponseHeadersFunction = (\n  request: Request,\n  headers: Headers,\n) => void;\n\nexport function addDocumentResponseHeadersFactory(\n  params: BasicParams,\n): AddDocumentResponseHeadersFunction {\n  const {api, config} = params;\n\n  return function (request: Request, headers: Headers) {\n    const {searchParams} = new URL(request.url);\n    const shop = api.utils.sanitizeShop(searchParams.get('shop')!);\n\n    const isEmbeddedApp = config.distribution !== AppDistribution.ShopifyAdmin;\n    addDocumentResponseHeaders(headers, isEmbeddedApp, shop);\n  };\n}\n\nexport function addDocumentResponseHeaders(\n  headers: Headers,\n  isEmbeddedApp: boolean,\n  shop: string | null | undefined,\n) {\n  if (shop) {\n    headers.set(\n      'Link',\n      `<${CDN_URL}>; rel=\"preconnect\", <${APP_BRIDGE_URL}>; rel=\"preload\"; as=\"script\", <${POLARIS_URL}>; rel=\"preload\"; as=\"script\"`,\n    );\n  }\n\n  if (isEmbeddedApp) {\n    if (shop) {\n      headers.set(\n        'Content-Security-Policy',\n        `frame-ancestors https://${shop} https://admin.shopify.com https://*.spin.dev https://admin.myshopify.io https://admin.shop.dev;`,\n      );\n    }\n  } else {\n    headers.set('Content-Security-Policy', `frame-ancestors 'none';`);\n  }\n}\n", "import {ShopifyError} from '@shopify/shopify-api';\n\ninterface Options {\n  requireSSL?: boolean;\n  throwOnInvalid?: boolean;\n}\n\ntype SanitizedRedirectUrl<OptionsArg extends Options> =\n  OptionsArg['throwOnInvalid'] extends false ? URL | undefined : URL;\n\nconst FILE_URI_MATCH = /\\/\\/\\//;\nconst INVALID_RELATIVE_URL = /[/\\\\][/\\\\]/;\nconst WHITESPACE_CHARACTER = /\\s/;\nconst VALID_PROTOCOLS = ['https:', 'http:'];\n\nfunction isSafe(\n  domain: string,\n  redirectUrl: unknown,\n  requireSSL: boolean | undefined = true,\n): redirectUrl is string {\n  if (typeof redirectUrl !== 'string') {\n    return false;\n  }\n\n  if (\n    FILE_URI_MATCH.test(redirectUrl) ||\n    WHITESPACE_CHARACTER.test(redirectUrl)\n  ) {\n    return false;\n  }\n\n  let url: URL;\n\n  try {\n    url = new URL(redirectUrl, domain);\n  } catch (error) {\n    return false;\n  }\n\n  if (INVALID_RELATIVE_URL.test(url.pathname)) {\n    return false;\n  }\n\n  if (!VALID_PROTOCOLS.includes(url.protocol)) {\n    return false;\n  }\n\n  if (requireSSL && url.protocol !== 'https:') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function sanitizeRedirectUrl<OptionsArg extends Options>(\n  domain: string,\n  redirectUrl: unknown,\n  options: OptionsArg = {} as OptionsArg,\n): SanitizedRedirectUrl<OptionsArg> {\n  if (isSafe(domain, redirectUrl, options.requireSSL)) {\n    return new URL(redirectUrl, domain) as SanitizedRedirectUrl<OptionsArg>;\n  } else if (options.throwOnInvalid === false) {\n    return undefined as SanitizedRedirectUrl<OptionsArg>;\n  } else {\n    throw new ShopifyError('Invalid URL. Refusing to redirect');\n  }\n}\n", "import {BasicParams, AppDistribution} from '../../../types';\nimport {appBridgeUrl} from '../../helpers/app-bridge-url';\nimport {addDocumentResponseHeaders} from '../../helpers/add-response-headers';\n\nimport {sanitizeRedirectUrl} from './validate-redirect-url';\n\nimport type {RedirectTarget} from '.';\n\nexport interface RedirectToOptions {\n  url: string | URL;\n  target?: RedirectTarget;\n}\n\nexport function renderAppBridge(\n  {config}: BasicParams,\n  request: Request,\n  redirectTo?: RedirectToOptions,\n): never {\n  let redirectToScript = '';\n  if (redirectTo) {\n    const destination = sanitizeRedirectUrl(config.appUrl, redirectTo.url);\n\n    const target = redirectTo.target ?? '_top';\n\n    redirectToScript = `<script>window.open(${JSON.stringify(\n      destination.toString(),\n    )}, ${JSON.stringify(target)})</script>`;\n  }\n\n  const responseHeaders = new Headers({\n    'content-type': 'text/html;charset=utf-8',\n  });\n  const isEmbeddedApp = config.distribution !== AppDistribution.ShopifyAdmin;\n  addDocumentResponseHeaders(\n    responseHeaders,\n    isEmbeddedApp,\n    new URL(request.url).searchParams.get('shop'),\n  );\n\n  throw new Response(\n    `\n      <script data-api-key=\"${config.apiKey}\" src=\"${appBridgeUrl()}\"></script>\n      ${redirectToScript}\n    `,\n    {headers: responseHeaders},\n  );\n}\n", "import {redirect as reactRouterRedirect} from 'react-router';\n\nimport {BasicParams, AppDistribution} from '../../../types';\nimport {getSessionTokenHeader} from '../../helpers/get-session-token-header';\n\nimport {renderAppBridge} from './render-app-bridge';\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport type RedirectTarget = '_self' | '_parent' | '_top' | '_blank';\nexport type RedirectInit = number | (ResponseInit & {target?: RedirectTarget});\nexport type RedirectFunction = (url: string, init?: RedirectInit) => Response;\n\ninterface ParseURLOptions {\n  params: BasicParams;\n  url: string;\n  base: string;\n  shop: string;\n  init: RedirectInit;\n}\n\ninterface ParsedURL {\n  url: URL;\n  target: RedirectTarget;\n}\n\nexport function redirectFactory(\n  params: BasicParams,\n  request: Request,\n  shop: string,\n): RedirectFunction {\n  const {config, logger} = params;\n\n  return function redirect(url, init: RedirectInit) {\n    const {searchParams} = new URL(request.url);\n    const {url: parsedUrl, target} = parseURL({\n      params,\n      url,\n      base: config.appUrl,\n      shop,\n      init,\n    });\n\n    logger.debug('Redirecting', {shop, url: parsedUrl.toString()});\n\n    const isSameOrigin = parsedUrl.origin === config.appUrl;\n    if (isSameOrigin || url.startsWith('/')) {\n      searchParams.forEach((value, key) => {\n        if (!parsedUrl.searchParams.has(key)) {\n          parsedUrl.searchParams.set(key, value);\n        }\n      });\n    }\n\n    if (target === '_self') {\n      if (isBounceRequest(request)) {\n        throw renderAppBridge(params, request, {\n          url: parsedUrl.toString(),\n          target,\n        });\n      } else {\n        return reactRouterRedirect(parsedUrl.toString(), init);\n      }\n    } else if (isDataRequest(request)) {\n      throw redirectWithAppBridgeHeaders(parsedUrl.toString());\n    } else if (isEmbeddedRequest(request)) {\n      throw renderAppBridge(params, request, {\n        url: parsedUrl.toString(),\n        target,\n      });\n    }\n    return reactRouterRedirect(url, init);\n  };\n}\n\nfunction isBounceRequest(request: Request) {\n  return (\n    Boolean(getSessionTokenHeader(request)) &&\n    request.headers.has('X-Shopify-Bounce')\n  );\n}\n\nfunction isDataRequest(request: Request) {\n  const isGet = request.method === 'GET';\n  const sessionTokenHeader = Boolean(getSessionTokenHeader(request));\n\n  return (\n    sessionTokenHeader &&\n    !isBounceRequest(request) &&\n    (!isEmbeddedRequest(request) || !isGet)\n  );\n}\n\nfunction isEmbeddedRequest(request: Request) {\n  const {searchParams} = new URL(request.url);\n\n  return searchParams.get('embedded') === '1';\n}\n\nfunction parseURL({params, base, init, shop, url}: ParseURLOptions): ParsedURL {\n  let target: RedirectTarget | undefined =\n    typeof init !== 'number' && init?.target ? init.target : undefined;\n\n  if (isAdminRemotePath(url)) {\n    const {config} = params;\n\n    const adminPath = getAdminRemotePath(url);\n    const cleanShopName = shop.replace('.myshopify.com', '');\n\n    if (!target) {\n      target =\n        config.distribution === AppDistribution.ShopifyAdmin\n          ? '_self'\n          : '_parent';\n    }\n\n    return {\n      url: new URL(\n        `https://admin.shopify.com/store/${cleanShopName}${adminPath}`,\n      ),\n      target,\n    };\n  } else {\n    return {\n      url: new URL(url, base),\n      target: target ?? '_self',\n    };\n  }\n}\n\nconst ADMIN_REGEX = /^shopify:\\/*admin\\//i;\n\nfunction isAdminRemotePath(url: string) {\n  return ADMIN_REGEX.test(url);\n}\n\nfunction getAdminRemotePath(url: string | URL) {\n  const parsedUrl = removeRestrictedParams(new URL(url)).href;\n  return parsedUrl.replace(ADMIN_REGEX, '/');\n}\n\nconst embeddedFrameParamsToRemove = [\n  'hmac',\n  'locale',\n  'protocol',\n  'session',\n  'id_token',\n  'shop',\n  'timestamp',\n  'host',\n  'embedded',\n  // sent when clicking rel=\"home\" nav item\n  'appLoadId',\n];\n\nfunction removeRestrictedParams(url: URL | string) {\n  const newUrl = new URL(url);\n  embeddedFrameParamsToRemove.forEach((param) =>\n    newUrl.searchParams.delete(param),\n  );\n  return newUrl;\n}\n", "import {redirect} from 'react-router';\n\nimport {BasicParams, AppDistribution} from '../../../types';\n\nexport function validateShopAndHostParams(\n  params: BasicParams,\n  request: Request,\n) {\n  const {api, config, logger} = params;\n\n  if (config.distribution !== AppDistribution.ShopifyAdmin) {\n    const url = new URL(request.url);\n    const shop = api.utils.sanitizeShop(url.searchParams.get('shop')!);\n    if (!shop) {\n      logger.debug('Missing or invalid shop, redirecting to login path', {\n        shop,\n      });\n      throw redirectToLoginPath(request, params);\n    }\n\n    const host = api.utils.sanitizeHost(url.searchParams.get('host')!);\n    if (!host) {\n      logger.debug('Invalid host, redirecting to login path', {\n        shop,\n        host: url.searchParams.get('host'),\n      });\n      throw redirectToLoginPath(request, params);\n    }\n  }\n}\n\nfunction redirectToLoginPath(request: Request, params: BasicParams): never {\n  const {config, logger} = params;\n\n  const {pathname} = new URL(request.url);\n  if (pathname === config.auth.loginPath) {\n    const message =\n      `Detected call to shopify.authenticate.admin() from configured login path ` +\n      `('${config.auth.loginPath}'), please make sure to call shopify.login() from that route instead.`;\n\n    logger.debug(message);\n    throw new Response(message, {status: 500});\n  }\n\n  throw redirect(config.auth.loginPath);\n}\n", "import {redirect as reactRouterRedirect} from 'react-router';\n\nimport type {BasicParams} from '../../../types';\nimport {AppDistribution} from '../../../types';\n\nimport {redirectWithAppBridgeHeaders} from './redirect-with-app-bridge-headers';\n\nexport async function redirectToInstallPage(\n  params: BasicParams,\n  shop: string,\n  optionalScopes: string[] = [],\n): Promise<never> {\n  const installUrl = buildInstallUrl(params, shop, optionalScopes);\n  if (params.config.distribution === AppDistribution.ShopifyAdmin) {\n    throw reactRouterRedirect(installUrl);\n  } else {\n    throw redirectWithAppBridgeHeaders(installUrl);\n  }\n}\n\nfunction buildInstallUrl(\n  params: BasicParams,\n  shop: string,\n  optionalScopes: string[] = [],\n) {\n  const baseInstallUrl = buildBaseInstallUrl(params, shop);\n  baseInstallUrl.search = buildParamsInstallUrl(\n    params,\n    optionalScopes,\n  ).toString();\n  return baseInstallUrl.href;\n}\n\nfunction buildBaseInstallUrl({api}: BasicParams, shop: string) {\n  const cleanShop = api.utils.sanitizeShop(shop, true);\n  return new URL(`https://${cleanShop}/admin/oauth/install`);\n}\n\nfunction buildParamsInstallUrl(\n  {config}: BasicParams,\n  optionalScopes: string[] = [],\n) {\n  const optionalScopesParam =\n    optionalScopes && optionalScopes.length > 0\n      ? {optional_scopes: optionalScopes.join(',')}\n      : undefined;\n\n  const query = {\n    client_id: config.apiKey,\n    scope: config.scopes?.toString() || '',\n    ...optionalScopesParam,\n  };\n  return new URLSearchParams(query);\n}\n", "import {AdminApiContext} from '../../../../clients';\n\nexport interface FetchScopesDetailResponse {\n  app: {\n    requestedAccessScopes: {\n      handle: string;\n    }[];\n    optionalAccessScopes: {\n      handle: string;\n    }[];\n    installation: {\n      accessScopes: {\n        handle: string;\n      }[];\n    };\n  };\n}\n\nconst FETCH_SCOPES_DETAIL_QUERY = `#graphql\nquery FetchAccessScopes{\n  app {\n    requestedAccessScopes {\n      handle\n    }\n    optionalAccessScopes {\n      handle\n    }\n    installation {\n      accessScopes {\n        handle\n      }\n    }\n  }\n}`;\n\nexport async function fetchScopeDetail(\n  admin: AdminApiContext,\n): Promise<FetchScopesDetailResponse> {\n  const fetchScopeDetailResult = await admin.graphql(FETCH_SCOPES_DETAIL_QUERY);\n\n  const resultContent = await fetchScopeDetailResult.json();\n  return resultContent.data;\n}\n", "import {AuthScopes, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {redirectToInstallPage} from '../helpers/redirect-to-install-page';\nimport {AdminApiContext} from '../../../clients';\n\nimport {fetchScopeDetail} from './client/fetch-scopes-details';\n\nexport function requestScopesFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n) {\n  return async function requestScopes(scopes: string[]) {\n    const {logger} = params;\n\n    logger.debug('Requesting optional scopes: ', {shop: session.shop, scopes});\n\n    if (scopes.length === 0) return;\n    if (await alreadyGranted(scopes, admin)) return;\n\n    throw await redirectToInstallPage(params, session.shop, scopes);\n  };\n\n  async function alreadyGranted(scopes: string[], admin: AdminApiContext) {\n    const scopesDetail = await fetchScopeDetail(admin);\n    const grantedScopes = scopesDetail.app.installation.accessScopes.map(\n      (scope) => scope.handle,\n    );\n    return new AuthScopes(grantedScopes).has(scopes);\n  }\n}\n", "import {AuthScopes, Session} from '@shopify/shopify-api';\n\nimport {AdminApiContext} from '../../../clients';\nimport type {BasicParams} from '../../../types';\n\nimport {ScopesDetail} from './types';\nimport {\n  FetchScopesDetailResponse,\n  fetchScopeDetail,\n} from './client/fetch-scopes-details';\n\nexport function queryScopesFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n) {\n  return async function queryScopes() {\n    const {logger} = params;\n\n    logger.debug('Querying scopes details: ', {\n      shop: session.shop,\n    });\n\n    const scopesDetail = await fetchScopeDetail(admin);\n    return mapFetchScopeDetail(scopesDetail);\n  };\n}\n\nexport function mapFetchScopeDetail(\n  scopesDetailResponse: FetchScopesDetailResponse,\n): ScopesDetail {\n  const appInformation = scopesDetailResponse.app;\n\n  const granted = new AuthScopes(\n    appInformation.installation.accessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  const required = new AuthScopes(\n    appInformation.requestedAccessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  const optional = new AuthScopes(\n    appInformation.optionalAccessScopes.map((scope) => scope.handle),\n  ).toArray(true);\n\n  return {\n    granted,\n    required,\n    optional,\n  };\n}\n", "import {AdminApiContext} from '../../../../clients';\n\nexport interface RevokeScopesResponse {\n  revoked: {\n    handle: string;\n  }[];\n  userErrors: {\n    field: string;\n    message: string;\n  }[];\n}\n\nconst REVOKE_SCOPE_MUTATION = `#graphql\nmutation AppRevokeAccessScopes($scopes: [String!]!) {\n  appRevokeAccessScopes(scopes: $scopes){\n    revoked {\n      handle\n    }\n    userErrors {\n      field\n      message\n    }\n  }\n}`;\n\nexport async function revokeScopes(\n  admin: AdminApiContext,\n  scopes: string[],\n): Promise<RevokeScopesResponse> {\n  const revokeScopesResult = await admin.graphql(REVOKE_SCOPE_MUTATION, {\n    variables: {\n      scopes,\n    },\n  });\n\n  const resultContent = await revokeScopesResult.json();\n  return resultContent.data.appRevokeAccessScopes;\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {AdminApiContext} from '../../../clients';\nimport type {BasicParams} from '../../../types';\n\nimport {revokeScopes} from './client/revoke-scopes';\n\nexport function revokeScopesFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n) {\n  return async function revoke(scopes: string[]) {\n    const {logger} = params;\n\n    await validateScopes(scopes);\n\n    logger.debug('Revoke scopes: ', {\n      shop: session.shop,\n      scopes,\n    });\n\n    const revokeScopesResult = await revokeScopes(admin, scopes);\n    if (revokeScopesResult.userErrors?.length > 0) {\n      logger.error('Failed to revoke scopes: ', {\n        shop: session.shop,\n        errors: revokeScopesResult.userErrors,\n      });\n\n      throw new Response(JSON.stringify(revokeScopesResult.userErrors), {\n        status: 422,\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    }\n\n    return {\n      revoked: revokeScopesResult.revoked.map((scope) => scope.handle),\n    };\n  };\n}\n\nasync function validateScopes(scopes: string[]) {\n  if (!scopes || scopes.length === 0) {\n    throw new Response('No scopes provided', {status: 400});\n  }\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../../types';\nimport {AdminApiContext} from '../../../clients';\n\nimport {ScopesApiContext} from './types';\nimport {requestScopesFactory} from './request';\nimport {queryScopesFactory} from './query';\nimport {revokeScopesFactory} from './revoke';\n\nexport function scopesApiFactory(\n  params: BasicParams,\n  session: Session,\n  admin: AdminApiContext,\n): ScopesApiContext {\n  return {\n    query: queryScopesFactory(params, session, admin),\n    request: requestScopesFactory(params, session, admin),\n    revoke: revokeScopesFactory(params, session, admin),\n  };\n}\n", "import {JwtPayload, Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\nimport {AppDistribution} from '../../types';\nimport type {AppConfigArg} from '../../config-types';\nimport {\n  getSessionTokenHeader,\n  ensureCORSHeadersFactory,\n  getSessionTokenFromUrlParam,\n  respondToBotRequest,\n  respondToOptionsRequest,\n  validateSessionToken,\n  getShopFromRequest,\n} from '../helpers';\n\nimport {\n  cancelBillingFactory,\n  requestBillingFactory,\n  requireBillingFactory,\n  checkBillingFactory,\n  createUsageRecordFactory,\n  updateUsageCappedAmountFactory,\n} from './billing';\nimport type {\n  AdminContext,\n  AuthenticateAdmin,\n  EmbeddedAdminContext,\n  NonEmbeddedAdminContext,\n} from './types';\nimport {\n  createAdminApiContext,\n  ensureAppIsEmbeddedIfRequired,\n  ensureSessionTokenSearchParamIfRequired,\n  redirectFactory,\n  renderAppBridge,\n  validateShopAndHostParams,\n} from './helpers';\nimport {AuthorizationStrategy} from './strategies/types';\nimport {scopesApiFactory} from './scope/factory';\n\nexport interface SessionTokenContext {\n  shop: string;\n  sessionId?: string;\n  sessionToken?: string;\n  payload?: JwtPayload;\n}\n\ninterface AuthStrategyParams extends BasicParams {\n  strategy: AuthorizationStrategy;\n}\n\nexport function authStrategyFactory<ConfigArg extends AppConfigArg>({\n  strategy,\n  ...params\n}: AuthStrategyParams): AuthenticateAdmin<ConfigArg> {\n  const {api, logger, config} = params;\n\n  async function respondToBouncePageRequest(request: Request) {\n    const url = new URL(request.url);\n\n    if (url.pathname === config.auth.patchSessionTokenPath) {\n      logger.debug('Rendering bounce page', {\n        shop: getShopFromRequest(request),\n      });\n      throw renderAppBridge({config, logger, api}, request);\n    }\n  }\n\n  async function respondToExitIframeRequest(request: Request) {\n    const url = new URL(request.url);\n\n    if (url.pathname === config.auth.exitIframePath) {\n      const destination = url.searchParams.get('exitIframe')!;\n\n      logger.debug('Rendering exit iframe page', {\n        shop: getShopFromRequest(request),\n        destination,\n      });\n      throw renderAppBridge({config, logger, api}, request, {url: destination});\n    }\n  }\n\n  type AdminContextBase =\n    | EmbeddedAdminContext<ConfigArg>\n    | NonEmbeddedAdminContext<ConfigArg>;\n\n  function createContext(\n    request: Request,\n    session: Session,\n    authStrategy: AuthorizationStrategy,\n    sessionToken?: JwtPayload,\n  ): AdminContext<ConfigArg> {\n    let context: AdminContextBase = {\n      admin: createAdminApiContext(\n        session,\n        params,\n        authStrategy.handleClientError(request),\n      ),\n      billing: {\n        require: requireBillingFactory(params, request, session),\n        check: checkBillingFactory(params, request, session),\n        request: requestBillingFactory(params, request, session),\n        cancel: cancelBillingFactory(params, request, session),\n        createUsageRecord: createUsageRecordFactory(params, request, session),\n        updateUsageCappedAmount: updateUsageCappedAmountFactory(\n          params,\n          request,\n          session,\n        ),\n      },\n\n      session,\n      cors: ensureCORSHeadersFactory(params, request),\n    };\n\n    context = addEmbeddedFeatures(context, request, session, sessionToken);\n    context = addScopesFeatures(context);\n\n    return context as AdminContext<ConfigArg>;\n  }\n\n  function addEmbeddedFeatures(\n    context: AdminContextBase,\n    request: Request,\n    session: Session,\n    sessionToken?: JwtPayload,\n  ) {\n    if (config.distribution === AppDistribution.ShopifyAdmin) {\n      return context;\n    }\n    return {\n      ...context,\n      sessionToken,\n      redirect: redirectFactory(params, request, session.shop),\n    };\n  }\n\n  function addScopesFeatures(context: AdminContextBase) {\n    return {\n      ...context,\n      scopes: scopesApiFactory(params, context.session, context.admin),\n    };\n  }\n\n  return async function authenticateAdmin(request: Request) {\n    try {\n      respondToBotRequest(params, request);\n      respondToOptionsRequest(params, request);\n      await respondToBouncePageRequest(request);\n      await respondToExitIframeRequest(request);\n\n      // If this is a valid request, but it doesn't have a session token header, this is a document request. We need to\n      // ensure we're embedded if needed and we have the information needed to load the session.\n      if (!getSessionTokenHeader(request)) {\n        validateShopAndHostParams(params, request);\n        await ensureAppIsEmbeddedIfRequired(params, request);\n        await ensureSessionTokenSearchParamIfRequired(params, request);\n      }\n\n      logger.info('Authenticating admin request', {\n        shop: getShopFromRequest(request),\n      });\n\n      const {payload, shop, sessionId, sessionToken} =\n        await getSessionTokenContext(params, request);\n\n      logger.debug('Loading session from storage', {shop, sessionId});\n      const existingSession = sessionId\n        ? await config.sessionStorage!.loadSession(sessionId)\n        : undefined;\n\n      const session = await strategy.authenticate(request, {\n        session: existingSession,\n        sessionToken,\n        shop,\n      });\n\n      return createContext(request, session, strategy, payload);\n    } catch (errorOrResponse) {\n      if (errorOrResponse instanceof Response) {\n        logger.debug('Authenticate returned a response', {\n          shop: getShopFromRequest(request),\n        });\n        ensureCORSHeadersFactory(params, request)(errorOrResponse);\n      }\n\n      throw errorOrResponse;\n    }\n  };\n}\n\nasync function getSessionTokenContext(\n  params: BasicParams,\n  request: Request,\n): Promise<SessionTokenContext> {\n  const {api, config, logger} = params;\n\n  const headerSessionToken = getSessionTokenHeader(request);\n  const searchParamSessionToken = getSessionTokenFromUrlParam(request);\n  const sessionToken = (headerSessionToken || searchParamSessionToken)!;\n\n  logger.debug('Attempting to authenticate session token', {\n    shop: getShopFromRequest(request),\n    sessionToken: JSON.stringify({\n      header: headerSessionToken,\n      search: searchParamSessionToken,\n    }),\n  });\n\n  if (config.distribution !== AppDistribution.ShopifyAdmin) {\n    const payload = await validateSessionToken(params, request, sessionToken);\n    const dest = new URL(payload.dest);\n    const shop = dest.hostname;\n\n    logger.debug('Session token is valid - authenticated', {shop, payload});\n    const sessionId = config.useOnlineTokens\n      ? api.session.getJwtSessionId(shop, payload.sub)\n      : api.session.getOfflineId(shop);\n\n    return {shop, payload, sessionId, sessionToken};\n  }\n\n  const url = new URL(request.url);\n  const shop = url.searchParams.get('shop')!;\n\n  const sessionId = await api.session.getCurrentId({\n    isOnline: config.useOnlineTokens,\n    rawRequest: request,\n  });\n\n  return {shop, sessionId, payload: undefined, sessionToken};\n}\n", "import {HttpResponseError} from '@shopify/shopify-api';\n\nimport type {HandleAdminClientError} from '../../../clients/admin/types';\nimport {HandleClientErrorOptions} from '../strategies/types';\n\nexport function handleClientErrorFactory({\n  request,\n  onError,\n}: HandleClientErrorOptions): HandleAdminClientError {\n  return async function handleClientError({\n    error,\n    params,\n    session,\n  }): Promise<never> {\n    if (error instanceof HttpResponseError !== true) {\n      params.logger.debug(\n        `Got a response error from the API: ${error.message}`,\n        {shop: session.shop},\n      );\n      throw error;\n    }\n\n    params.logger.debug(\n      `Got an HTTP response error from the API: ${error.message}`,\n      {\n        shop: session.shop,\n        code: error.response.code,\n        statusText: error.response.statusText,\n        body: JSON.stringify(error.response.body),\n      },\n    );\n\n    if (onError) {\n      await onError({request, session, error});\n    }\n\n    // forward a minimal copy of the upstream HTTP response instead of an Error:\n    throw new Response(JSON.stringify(error.response.body), {\n      status: error.response.code,\n      headers: {\n        'Content-Type': error.response.headers!['Content-Type'] as string,\n      },\n    });\n  };\n}\n", "import {AppDistribution, BasicParams} from '../../types';\n\nexport async function createOrLoadOfflineSession(\n  shop: string,\n  {api, config, logger}: BasicParams,\n) {\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    logger.debug('Creating custom app session from configured access token', {\n      shop,\n    });\n    return api.session.customAppSession(shop);\n  } else {\n    logger.debug('Loading offline session from session storage', {shop});\n    const offlineSessionId = api.session.getOfflineId(shop);\n    const session = await config.sessionStorage!.loadSession(offlineSessionId);\n\n    return session;\n  }\n}\n", "import {WebhookValidationErrorReason} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../types';\nimport {adminClientFactory} from '../../clients';\nimport {handleClientErrorFactory} from '../admin/helpers';\nimport {createOrLoadOfflineSession} from '../helpers';\n\nimport type {\n  AuthenticateWebhook,\n  WebhookContext,\n  WebhookContextWithoutSession,\n} from './types';\n\nexport function authenticateWebhookFactory<Topics extends string>(\n  params: BasicParams,\n): AuthenticateWebhook<Topics> {\n  const {api, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<WebhookContext<Topics>> {\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for a webhook. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n\n    const check = await api.webhooks.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!check.valid) {\n      if (check.reason === WebhookValidationErrorReason.InvalidHmac) {\n        logger.debug('Webhook HMAC validation failed', check);\n        throw new Response(undefined, {\n          status: 401,\n          statusText: 'Unauthorized',\n        });\n      } else {\n        logger.debug('Webhook validation failed', check);\n        throw new Response(undefined, {status: 400, statusText: 'Bad Request'});\n      }\n    }\n    const session = await createOrLoadOfflineSession(check.domain, params);\n    const webhookContext: WebhookContextWithoutSession<Topics> = {\n      apiVersion: check.apiVersion,\n      shop: check.domain,\n      topic: check.topic as Topics,\n      webhookId: check.webhookId,\n      payload: JSON.parse(rawBody),\n      subTopic: check.subTopic || undefined,\n      session: undefined,\n      admin: undefined,\n    };\n\n    if (!session) {\n      return webhookContext;\n    }\n\n    const admin = adminClientFactory({\n      params,\n      session,\n      handleClientError: handleClientErrorFactory({request}),\n    });\n\n    return {\n      ...webhookContext,\n      session,\n      admin,\n    };\n  };\n}\n", "import {compare} from 'compare-versions';\nimport {FeatureDeprecatedError, Shopify} from '@shopify/shopify-api';\n\nimport {SHOPIFY_REACT_ROUTER_LIBRARY_VERSION} from './version';\n\n// eslint-disable-next-line no-warning-comments\n// TODO This has been copied from shopify-app-express, it should be extracted into a shared package\n// https://github.com/orgs/Shopify/projects/6899/views/1?pane=issue&itemId=28358070\nexport function overrideLogger(logger: Shopify['logger']): Shopify['logger'] {\n  const baseContext = {package: 'shopify-app'};\n\n  const warningFunction: Shopify['logger']['warning'] = (\n    message,\n    context = {},\n  ) => logger.warning(message, {...baseContext, ...context});\n\n  function deprecated(warningFunction: Shopify['logger']['warning']) {\n    return function (version: string, message: string): Promise<void> {\n      if (compare(SHOPIFY_REACT_ROUTER_LIBRARY_VERSION, version, '>=')) {\n        throw new FeatureDeprecatedError(\n          `Feature was deprecated in version ${version}`,\n        );\n      }\n\n      return warningFunction(`[Deprecated | ${version}] ${message}`);\n    };\n  }\n\n  return {\n    ...logger,\n    log: (severity, message, context = {}) =>\n      logger.log(severity, message, {...baseContext, ...context}),\n    debug: (message, context = {}) =>\n      logger.debug(message, {...baseContext, ...context}),\n    info: (message, context = {}) =>\n      logger.info(message, {...baseContext, ...context}),\n    warning: warningFunction,\n    error: (message, context = {}) =>\n      logger.error(message, {...baseContext, ...context}),\n    deprecated: deprecated(warningFunction),\n  };\n}\n", "import {redirect} from 'react-router';\n\nimport {\n  BasicParams,\n  LoginError,\n  LoginErrorType,\n  AppDistribution,\n} from '../../types';\n\nexport function loginFactory(params: BasicParams) {\n  const {api, config, logger} = params;\n\n  return async function login(request: Request): Promise<LoginError | never> {\n    const url = new URL(request.url);\n    const shopParam = url.searchParams.get('shop');\n\n    if (request.method === 'GET' && !shopParam) {\n      return {};\n    }\n\n    const shop: string | null =\n      shopParam || ((await request.formData()).get('shop') as string);\n\n    if (!shop) {\n      logger.debug('Missing shop parameter', {shop});\n      return {shop: LoginErrorType.MissingShop};\n    }\n\n    const shopWithoutProtocol = shop\n      .replace(/^https?:\\/\\//, '')\n      .replace(/\\/$/, '');\n    const shopWithDomain =\n      shop?.indexOf('.') === -1\n        ? `${shopWithoutProtocol}.myshopify.com`\n        : shopWithoutProtocol;\n    const sanitizedShop = api.utils.sanitizeShop(shopWithDomain);\n\n    if (!sanitizedShop) {\n      logger.debug('Invalid shop parameter', {shop});\n      return {shop: LoginErrorType.InvalidShop};\n    }\n\n    const authPath = `${config.appUrl}${config.auth.path}?shop=${sanitizedShop}`;\n\n    const adminPath = api.utils.legacyUrlToShopAdminUrl(sanitizedShop);\n    const installPath = `https://${adminPath}/oauth/install?client_id=${config.apiKey}`;\n\n    const shouldInstall = config.distribution !== AppDistribution.ShopifyAdmin;\n    const redirectUrl = shouldInstall ? installPath : authPath;\n\n    logger.info(`Redirecting login request to ${redirectUrl}`, {\n      shop: sanitizedShop,\n    });\n\n    throw redirect(redirectUrl);\n  };\n}\n", "import {ShopifyError} from '@shopify/shopify-api';\n\nexport class SessionNotFoundError extends ShopifyError {}\n", "import {createOrLoadOfflineSession} from '../../authenticate/helpers/create-or-load-offline-session';\nimport {SessionNotFoundError} from '../../errors';\nimport {BasicParams} from '../../types';\nimport {adminClientFactory} from '../../clients/admin';\n\nimport {UnauthenticatedAdminContext} from './types';\n\nexport function unauthenticatedAdminContextFactory(params: BasicParams) {\n  return async (shop: string): Promise<UnauthenticatedAdminContext> => {\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      throw new SessionNotFoundError(\n        `Could not find a session for shop ${shop} when creating unauthenticated admin context`,\n      );\n    }\n\n    return {\n      session,\n      admin: adminClientFactory({params, session}),\n    };\n  };\n}\n", "import {BasicParams} from '../../../types';\nimport {\n  respondToBotRequest,\n  respondToOptionsRequest,\n  getSessionTokenHeader,\n  validateSessionToken,\n  ensureCORSHeadersFactory,\n  getShopFromRequest,\n} from '../../helpers';\n\nimport {AuthenticateExtension, ExtensionContext} from './types';\n\nexport function authenticateExtensionFactory(\n  params: BasicParams,\n  requestType: string,\n): AuthenticateExtension {\n  return async function authenticateExtension(\n    request,\n    options = {},\n  ): Promise<ExtensionContext> {\n    const {logger} = params;\n\n    const corsHeaders = options.corsHeaders ?? [];\n\n    respondToBotRequest(params, request);\n    respondToOptionsRequest(params, request, corsHeaders);\n\n    const sessionTokenHeader = getSessionTokenHeader(request);\n\n    logger.info(`Authenticating ${requestType} request`, {\n      shop: getShopFromRequest(request),\n    });\n\n    if (!sessionTokenHeader) {\n      logger.debug('Request did not contain a session token', {\n        shop: getShopFromRequest(request),\n      });\n      throw new Response(undefined, {\n        status: 401,\n        statusText: 'Unauthorized',\n      });\n    }\n\n    return {\n      sessionToken: await validateSessionToken(\n        params,\n        request,\n        sessionTokenHeader,\n        {checkAudience: false, retryRequest: false},\n      ),\n      cors: ensureCORSHeadersFactory(params, request, corsHeaders),\n    };\n  };\n}\n", "import type {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport type {AuthenticateCheckout} from './types';\n\nexport function authenticateCheckoutFactory(\n  params: BasicParams,\n): AuthenticateCheckout {\n  return authenticateExtensionFactory(\n    params,\n    'checkout',\n  ) as AuthenticateCheckout;\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport {BasicParams} from '../../types';\n\nimport type {StorefrontContext} from '.';\n\nexport function storefrontClientFactory({\n  params,\n  session,\n}: {\n  params: BasicParams;\n  session: Session;\n}): StorefrontContext {\n  const {api} = params;\n\n  return {\n    graphql: async (query, options = {}) => {\n      const client = new api.clients.Storefront({\n        session,\n        apiVersion: options.apiVersion,\n      });\n\n      const apiResponse = await client.request(query, {\n        variables: options?.variables,\n        retries: options?.tries ? options.tries - 1 : 0,\n        headers: options?.headers,\n      });\n\n      return new Response(JSON.stringify(apiResponse));\n    },\n  };\n}\n", "import {adminClientFactory, storefrontClientFactory} from '../../../clients';\nimport {BasicParams} from '../../../types';\n\nimport {\n  AppProxyContext,\n  AppProxyContextWithSession,\n  AuthenticateAppProxy,\n  LiquidResponseFunction,\n} from './types';\n\nexport function authenticateAppProxyFactory(\n  params: BasicParams,\n): AuthenticateAppProxy {\n  const {api, config, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<AppProxyContext | AppProxyContextWithSession> {\n    const url = new URL(request.url);\n    const shop = url.searchParams.get('shop')!;\n    logger.info('Authenticating app proxy request', {shop});\n\n    if (!(await validateAppProxyHmac(params, url))) {\n      logger.info('App proxy request has invalid signature', {shop});\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const sessionId = api.session.getOfflineId(shop);\n    const session = await config.sessionStorage!.loadSession(sessionId);\n\n    if (!session) {\n      logger.debug('Could not find offline session, returning empty context', {\n        shop,\n        ...Object.fromEntries(url.searchParams.entries()),\n      });\n\n      const context: AppProxyContext = {\n        liquid,\n        session: undefined,\n        admin: undefined,\n        storefront: undefined,\n      };\n\n      return context;\n    }\n\n    const context: AppProxyContextWithSession = {\n      liquid,\n      session,\n      admin: adminClientFactory({params, session}),\n      storefront: storefrontClientFactory({params, session}),\n    };\n\n    return context;\n  };\n}\n\nconst liquid: LiquidResponseFunction = (body, initAndOptions) => {\n  const processedBody = processLiquidBody(body);\n\n  if (typeof initAndOptions !== 'object') {\n    return new Response(processedBody, {\n      status: initAndOptions || 200,\n      headers: {\n        'Content-Type': 'application/liquid',\n      },\n    });\n  }\n\n  const {layout, ...responseInit} = initAndOptions || {};\n  const responseBody =\n    layout === false ? `{% layout none %} ${processedBody}` : processedBody;\n\n  const headers = new Headers(responseInit.headers);\n  headers.set('Content-Type', 'application/liquid');\n\n  return new Response(responseBody, {\n    ...responseInit,\n    headers,\n  });\n};\n\nasync function validateAppProxyHmac(\n  params: BasicParams,\n  url: URL,\n): Promise<boolean> {\n  const {api, logger} = params;\n\n  try {\n    let searchParams = new URLSearchParams(url.search);\n    if (!searchParams.get('index')) {\n      searchParams.delete('index');\n    }\n\n    let isValid = await api.utils.validateHmac(\n      Object.fromEntries(searchParams.entries()),\n      {signator: 'appProxy'},\n    );\n\n    if (!isValid) {\n      const cleanPath = url.pathname\n        .replace(/^\\//, '')\n        .replace(/\\/$/, '')\n        .replaceAll('/', '.');\n      const data = `routes%2F${cleanPath}`;\n\n      searchParams = new URLSearchParams(\n        `?_data=${data}&${searchParams.toString().replace(/^\\?/, '')}`,\n      );\n\n      isValid = await api.utils.validateHmac(\n        Object.fromEntries(searchParams.entries()),\n        {signator: 'appProxy'},\n      );\n\n      if (!isValid) {\n        const searchParams = new URLSearchParams(\n          `?_data=${data}._index&${url.search.replace(/^\\?/, '')}`,\n        );\n\n        isValid = await api.utils.validateHmac(\n          Object.fromEntries(searchParams.entries()),\n          {signator: 'appProxy'},\n        );\n      }\n    }\n\n    return isValid;\n  } catch (error) {\n    const shop = url.searchParams.get('shop')!;\n    logger.info(error.message, {shop});\n    throw new Response(undefined, {status: 400, statusText: 'Bad Request'});\n  }\n}\n\nfunction processLiquidBody(body: string) {\n  return (\n    body\n      // Add trailing slashes to relative form action URLs\n      .replaceAll(\n        /<(form[^>]+)action=\"(\\/[^\"?]+)(\\?[^\"]+)?\">/g,\n        '<$1action=\"$2/$3\">',\n      )\n      // Add trailing slashes to relative link href URLs\n      .replaceAll(/<(a[^>]+)href=\"(\\/[^\"?]+)(\\?[^\"]+)?\">/g, '<$1href=\"$2/$3\">')\n  );\n}\n", "import {BasicParams} from '../../../types';\nimport {authenticateExtensionFactory} from '../extension/authenticate';\n\nimport {AuthenticateCustomerAccount} from './types';\n\nexport function authenticateCustomerAccountFactory(\n  params: BasicParams,\n): AuthenticateCustomerAccount {\n  return authenticateExtensionFactory(\n    params,\n    'customer account',\n  ) as AuthenticateCustomerAccount;\n}\n", "import {BasicParams} from '../../types';\n\nimport {authenticateCheckoutFactory} from './checkout/authenticate';\nimport {authenticateAppProxyFactory} from './appProxy/authenticate';\nimport {authenticateCustomerAccountFactory} from './customer-account/authenticate';\nimport {AuthenticatePublic} from './types';\n\nexport function authenticatePublicFactory(params: BasicParams) {\n  const authenticateCheckout = authenticateCheckoutFactory(params);\n  const authenticateAppProxy = authenticateAppProxyFactory(params);\n  const authenticateCustomerAccount =\n    authenticateCustomerAccountFactory(params);\n\n  const context: AuthenticatePublic = {\n    checkout: authenticateCheckout,\n    appProxy: authenticateAppProxy,\n    customerAccount: authenticateCustomerAccount,\n  };\n\n  return context;\n}\n", "import {createOrLoadOfflineSession} from '../../authenticate/helpers/create-or-load-offline-session';\nimport {SessionNotFoundError} from '../../errors';\nimport {BasicParams} from '../../types';\nimport {storefrontClientFactory} from '../../clients/storefront';\n\nimport {\n  UnauthenticatedStorefrontContext,\n  GetUnauthenticatedStorefrontContext,\n} from './types';\n\nexport function unauthenticatedStorefrontContextFactory(\n  params: BasicParams,\n): GetUnauthenticatedStorefrontContext {\n  return async (shop: string): Promise<UnauthenticatedStorefrontContext> => {\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      throw new SessionNotFoundError(\n        `Could not find a session for shop ${shop} when creating unauthenticated storefront context`,\n      );\n    }\n\n    return {\n      session,\n      storefront: storefrontClientFactory({params, session}),\n    };\n  };\n}\n", "import {Session} from '@shopify/shopify-api';\n\nimport type {BasicParams} from '../../../types';\nimport {AuthorizationStrategy} from '../strategies/types';\n\nimport {createAdminApiContext} from './create-admin-api-context';\n\nexport async function triggerAfterAuthHook(\n  params: BasicParams,\n  session: Session,\n  request: Request,\n  authStrategy: AuthorizationStrategy,\n) {\n  const {config, logger} = params;\n  if (config.hooks.afterAuth) {\n    logger.info('Running afterAuth hook', {shop: session.shop});\n\n    const admin = createAdminApiContext(\n      session,\n      params,\n      authStrategy.handleClientError(request),\n    );\n\n    await config.hooks.afterAuth({\n      session,\n      admin,\n    });\n  }\n}\n", "import {\n  HttpResponseError,\n  InvalidJwtError,\n  RequestedTokenType,\n  Session,\n} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {\n  respondToInvalidSessionToken,\n  invalidateAccessToken,\n  getShopFromRequest,\n} from '../../helpers';\nimport {handleClientErrorFactory, triggerAfterAuthHook} from '../helpers';\nimport {HandleAdminClientError} from '../../../clients';\n\nimport {\n  AuthorizationStrategy,\n  SessionContext,\n  OnErrorOptions,\n  AuthStrategyFactory,\n} from './types';\n\nexport const createTokenExchangeStrategy: AuthStrategyFactory<any> = <\n  Config extends AppConfigArg,\n>(\n  params: BasicParams<Config['future']>,\n): AuthorizationStrategy => {\n  const {api, config, logger} = params;\n\n  async function exchangeToken({\n    request,\n    shop,\n    sessionToken,\n    requestedTokenType,\n  }: {\n    request: Request;\n    shop: string;\n    sessionToken: string;\n    requestedTokenType: RequestedTokenType;\n  }): Promise<{session: Session}> {\n    try {\n      return await api.auth.tokenExchange({\n        sessionToken,\n        shop,\n        requestedTokenType,\n      });\n    } catch (error) {\n      if (\n        error instanceof InvalidJwtError ||\n        (error instanceof HttpResponseError &&\n          error.response.code === 400 &&\n          error.response.body?.error === 'invalid_subject_token')\n      ) {\n        throw respondToInvalidSessionToken({\n          params: {api, config, logger},\n          request,\n          retryRequest: true,\n        });\n      }\n\n      throw new Response(undefined, {\n        status: 500,\n        statusText: 'Internal Server Error',\n      });\n    }\n  }\n\n  async function handleAfterAuthHook(\n    session: Session,\n    request: Request,\n    sessionToken: string,\n  ) {\n    await config.idempotentPromiseHandler.handlePromise({\n      promiseFunction: () => {\n        return triggerAfterAuthHook(params, session, request, {\n          authenticate,\n          handleClientError,\n        });\n      },\n      identifier: sessionToken,\n    });\n  }\n\n  async function authenticate(\n    request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session> {\n    const {shop, session, sessionToken} = sessionContext;\n\n    if (!sessionToken) throw new InvalidJwtError();\n\n    if (!session || !session.isActive(undefined)) {\n      logger.info('No valid session found', {shop});\n      logger.info('Requesting offline access token', {shop});\n      const {session: offlineSession} = await exchangeToken({\n        request,\n        sessionToken,\n        shop,\n        requestedTokenType: RequestedTokenType.OfflineAccessToken,\n      });\n\n      await config.sessionStorage!.storeSession(offlineSession);\n\n      let newSession = offlineSession;\n\n      if (config.useOnlineTokens) {\n        logger.info('Requesting online access token', {shop});\n        const {session: onlineSession} = await exchangeToken({\n          request,\n          sessionToken,\n          shop,\n          requestedTokenType: RequestedTokenType.OnlineAccessToken,\n        });\n\n        await config.sessionStorage!.storeSession(onlineSession);\n        newSession = onlineSession;\n      }\n\n      logger.debug('Request is valid, loaded session from session token', {\n        shop: newSession.shop,\n        isOnline: newSession.isOnline,\n      });\n\n      try {\n        await handleAfterAuthHook(newSession, request, sessionToken);\n      } catch (errorOrResponse) {\n        if (errorOrResponse instanceof Response) {\n          throw errorOrResponse;\n        }\n\n        throw new Response(undefined, {\n          status: 500,\n          statusText: 'Internal Server Error',\n        });\n      }\n\n      return newSession;\n    }\n\n    return session!;\n  }\n\n  function handleClientError(request: Request): HandleAdminClientError {\n    return handleClientErrorFactory({\n      request,\n      onError: async ({session, error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          logger.debug('Responding to invalid access token', {\n            shop: getShopFromRequest(request),\n          });\n          await invalidateAccessToken({config, api, logger}, session);\n\n          respondToInvalidSessionToken({\n            params: {config, api, logger},\n            request,\n          });\n        }\n      },\n    });\n  }\n\n  return {\n    authenticate,\n    handleClientError,\n  };\n};\n", "import {Session, ShopifyError} from '@shopify/shopify-api';\n\nimport {AppConfigArg} from '../../../config-types';\nimport {BasicParams} from '../../../types';\nimport {HandleAdminClientError} from '../../../clients';\nimport {handleClientErrorFactory} from '../helpers';\n\nimport {\n  AuthorizationStrategy,\n  OnErrorOptions,\n  SessionContext,\n  AuthStrategyFactory,\n} from './types';\n\nexport const createMerchantCustomAuthStrategy: AuthStrategyFactory<any> = <\n  Config extends AppConfigArg,\n>(\n  params: BasicParams<Config['future']>,\n): AuthorizationStrategy => {\n  const {api, logger} = params;\n\n  async function authenticate(\n    _request: Request,\n    sessionContext: SessionContext,\n  ): Promise<Session | never> {\n    const {shop} = sessionContext;\n\n    logger.debug(\n      'Building session from configured access token for merchant custom app',\n      {shop},\n    );\n    const session = api.session.customAppSession(shop);\n\n    return session;\n  }\n\n  function handleClientError(request: Request): HandleAdminClientError {\n    return handleClientErrorFactory({\n      request,\n      onError: async ({error}: OnErrorOptions) => {\n        if (error.response.code === 401) {\n          logger.info(\n            'Request failed with 401. Review your API credentials or generate new tokens. https://shopify.dev/docs/apps/build/authentication-authorization/access-token-types/generate-app-access-tokens-admin#rotating-api-credentials-for-admin-created-apps ',\n          );\n          throw new ShopifyError(\n            'Unauthorized: Access token has been revoked.',\n          );\n        }\n      },\n    });\n  }\n\n  return {\n    authenticate,\n    handleClientError,\n  };\n};\n", "export interface IdempotentHandlePromiseParams {\n  promiseFunction: () => Promise<any>;\n  identifier: string;\n}\n\nconst IDENTIFIER_TTL_MS = 60000;\n\nexport class IdempotentPromiseHandler {\n  protected identifiers: Map<string, number>;\n\n  constructor() {\n    this.identifiers = new Map<string, number>();\n  }\n\n  async handlePromise({\n    promiseFunction,\n    identifier,\n  }: IdempotentHandlePromiseParams): Promise<any> {\n    try {\n      if (this.isPromiseRunnable(identifier)) {\n        await promiseFunction();\n      }\n    } finally {\n      this.clearStaleIdentifiers();\n    }\n\n    return Promise.resolve();\n  }\n\n  private isPromiseRunnable(identifier: string) {\n    if (!this.identifiers.has(identifier)) {\n      this.identifiers.set(identifier, Date.now());\n      return true;\n    }\n    return false;\n  }\n\n  private async clearStaleIdentifiers() {\n    this.identifiers.forEach((date, identifier, map) => {\n      if (Date.now() - date > IDENTIFIER_TTL_MS) {\n        map.delete(identifier);\n      }\n    });\n  }\n}\n", "import {adminClientFactory} from '../../clients/admin';\nimport {BasicParams} from '../../types';\n\nimport type {AuthenticateFlow, FlowContext} from './types';\n\nexport function authenticateFlowFactory(params: BasicParams): AuthenticateFlow {\n  const {api, config, logger} = params;\n\n  return async function authenticate(request: Request): Promise<FlowContext> {\n    logger.info('Authenticating flow request');\n\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for flow. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n    const result = await api.flow.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!result.valid) {\n      logger.error('Received an invalid flow request', {reason: result.reason});\n\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const payload = JSON.parse(rawBody);\n\n    logger.debug('Flow request is valid, looking for an offline session', {\n      shop: payload.shopify_domain,\n    });\n\n    const sessionId = api.session.getOfflineId(payload.shopify_domain);\n    const session = await config.sessionStorage!.loadSession(sessionId);\n\n    if (!session) {\n      logger.info('Flow request could not find session', {\n        shop: payload.shopify_domain,\n      });\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    logger.debug('Found a session for the flow request', {shop: session.shop});\n\n    return {\n      session,\n      payload,\n      admin: adminClientFactory({params, session}),\n    };\n  };\n}\n", "import {ShopifyHeader} from '@shopify/shopify-api';\n\nimport {adminClientFactory} from '../../clients/admin';\nimport {BasicParams} from '../../types';\nimport {createOrLoadOfflineSession} from '../helpers';\n\nimport type {\n  AuthenticateFulfillmentService,\n  FulfillmentServiceContext,\n} from './types';\n\nexport function authenticateFulfillmentServiceFactory(\n  params: BasicParams,\n): AuthenticateFulfillmentService {\n  const {api, logger} = params;\n\n  return async function authenticate(\n    request: Request,\n  ): Promise<FulfillmentServiceContext> {\n    logger.info('Authenticating fulfillment service request');\n\n    if (request.method !== 'POST') {\n      logger.debug(\n        'Received a non-POST request for fulfillment service. Only POST requests are allowed.',\n        {url: request.url, method: request.method},\n      );\n      throw new Response(undefined, {\n        status: 405,\n        statusText: 'Method not allowed',\n      });\n    }\n\n    const rawBody = await request.text();\n    const result = await api.fulfillmentService.validate({\n      rawBody,\n      rawRequest: request,\n    });\n\n    if (!result.valid) {\n      logger.error('Received an invalid fulfillment service request', {\n        reason: result.reason,\n      });\n\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    const payload = JSON.parse(rawBody);\n    const shop = request.headers.get(ShopifyHeader.Domain) || '';\n\n    logger.debug(\n      'Fulfillment service request is valid, looking for an offline session',\n      {\n        shop,\n      },\n    );\n\n    const session = await createOrLoadOfflineSession(shop, params);\n\n    if (!session) {\n      logger.info('Fulfillment service request could not find session', {\n        shop,\n      });\n      throw new Response(undefined, {\n        status: 400,\n        statusText: 'Bad Request',\n      });\n    }\n\n    logger.debug('Found a session for the fulfillment service request', {\n      shop,\n    });\n\n    return {\n      session,\n      payload,\n      admin: adminClientFactory({params, session}),\n    };\n  };\n}\n", "import {BasicParams} from '../../types';\nimport {authenticateExtensionFactory} from '../public/extension/authenticate';\n\nimport type {AuthenticatePOS} from './types';\n\nexport function authenticatePOSFactory(params: BasicParams): AuthenticatePOS {\n  return authenticateExtensionFactory(params, 'pos') as AuthenticatePOS;\n}\n", "import '@shopify/shopify-api/adapters/web-api';\nimport {\n  ConfigInterface as ApiConfig,\n  ShopifyError,\n  shopifyApi,\n} from '@shopify/shopify-api';\nimport {SessionStorage} from '@shopify/shopify-app-session-storage';\n\nimport {type AppConfig, type AppConfigArg} from './config-types';\nimport {\n  AppDistribution,\n  type BasicParams,\n  type ShopifyApp,\n  type ShopifyAppBase,\n  type AdminApp,\n  type SingleMerchantApp,\n  type AppStoreApp,\n} from './types';\nimport {SHOPIFY_REACT_ROUTER_LIBRARY_VERSION} from './version';\nimport {registerWebhooksFactory} from './authenticate/webhooks';\nimport {authStrategyFactory} from './authenticate/admin/authenticate';\nimport {authenticateWebhookFactory} from './authenticate/webhooks/authenticate';\nimport {overrideLogger} from './override-logger';\nimport {addDocumentResponseHeadersFactory} from './authenticate/helpers';\nimport {loginFactory} from './authenticate/login/login';\nimport {unauthenticatedAdminContextFactory} from './unauthenticated/admin';\nimport {authenticatePublicFactory} from './authenticate/public';\nimport {unauthenticatedStorefrontContextFactory} from './unauthenticated/storefront';\nimport {createTokenExchangeStrategy} from './authenticate/admin/strategies/token-exchange';\nimport {createMerchantCustomAuthStrategy} from './authenticate/admin/strategies/merchant-custom-app';\nimport {IdempotentPromiseHandler} from './authenticate/helpers/idempotent-promise-handler';\nimport {authenticateFlowFactory} from './authenticate/flow/authenticate';\nimport {authenticateFulfillmentServiceFactory} from './authenticate/fulfillment-service/authenticate';\nimport {authenticatePOSFactory} from './authenticate/pos/authenticate';\nimport {FutureFlagOptions, logDisabledFutureFlags} from './future/flags';\n\n/**\n * Creates an object your app will use to interact with Shopify.\n *\n * @param appConfig Configuration options for your Shopify app, such as the scopes your app needs.\n * @returns `ShopifyApp` An object constructed using your appConfig.  It has methods for interacting with Shopify.\n *\n * @example\n * <caption>The minimum viable configuration</caption>\n * ```ts\n * // /shopify.server.ts\n * import { shopifyApp } from \"@shopify/shopify-app-react-router/server\";\n *\n * const shopify = shopifyApp({\n *   apiKey: process.env.SHOPIFY_API_KEY!,\n *   apiSecretKey: process.env.SHOPIFY_API_SECRET!,\n *   scopes: process.env.SCOPES?.split(\",\")!,\n *   appUrl: process.env.SHOPIFY_APP_URL!,\n * });\n * export default shopify;\n * ```\n */\nexport function shopifyApp<\n  Config extends AppConfigArg<Storage, Future>,\n  Storage extends SessionStorage,\n  Future extends FutureFlagOptions = Config['future'],\n>(appConfig: Readonly<Config>): ShopifyApp<Config> {\n  const api = deriveApi(appConfig);\n  const config = deriveConfig<Storage>(appConfig, api.config);\n  const logger = overrideLogger(api.logger);\n\n  if (appConfig.webhooks) {\n    api.webhooks.addHandlers(appConfig.webhooks);\n  }\n\n  const params: BasicParams = {api, config, logger};\n\n  let strategy;\n  if (config.distribution === AppDistribution.ShopifyAdmin) {\n    strategy = createMerchantCustomAuthStrategy(params);\n  } else {\n    strategy = createTokenExchangeStrategy(params);\n  }\n\n  const authStrategy = authStrategyFactory({\n    ...params,\n    strategy,\n  });\n\n  const shopify:\n    | AdminApp<Config>\n    | AppStoreApp<Config>\n    | SingleMerchantApp<Config> = {\n    sessionStorage: config.sessionStorage,\n    addDocumentResponseHeaders: addDocumentResponseHeadersFactory(params),\n    registerWebhooks: registerWebhooksFactory(params),\n    authenticate: {\n      admin: authStrategy,\n      flow: authenticateFlowFactory(params),\n      fulfillmentService: authenticateFulfillmentServiceFactory(params),\n      pos: authenticatePOSFactory(params),\n      public: authenticatePublicFactory(params),\n      webhook: authenticateWebhookFactory<string>(params),\n    },\n    unauthenticated: {\n      admin: unauthenticatedAdminContextFactory(params),\n      storefront: unauthenticatedStorefrontContextFactory(params),\n    },\n  };\n\n  if (\n    isAppStoreApp(shopify, appConfig) ||\n    isSingleMerchantApp(shopify, appConfig)\n  ) {\n    shopify.login = loginFactory(params);\n  }\n\n  logDisabledFutureFlags(config, logger);\n\n  return shopify as ShopifyApp<Config>;\n}\n\nfunction isAppStoreApp<Config extends AppConfigArg>(\n  _shopify: ShopifyAppBase<Config>,\n  config: Config,\n): _shopify is AppStoreApp<Config> {\n  return config.distribution === AppDistribution.AppStore;\n}\n\nfunction isSingleMerchantApp<Config extends AppConfigArg>(\n  _shopify: ShopifyAppBase<Config>,\n  config: Config,\n): _shopify is SingleMerchantApp<Config> {\n  return config.distribution === AppDistribution.SingleMerchant;\n}\n\n// This function is only exported so we can unit test it without having to mock the underlying module.\n// It's not available to consumers of the library because it is not exported in the index module, and never should be.\nexport function deriveApi(appConfig: AppConfigArg): BasicParams['api'] {\n  let appUrl: URL;\n  try {\n    appUrl = new URL(appConfig.appUrl);\n  } catch (error) {\n    const message =\n      appConfig.appUrl === ''\n        ? `Detected an empty appUrl configuration, please make sure to set the necessary environment variables.\\n` +\n          `If you're deploying your app, you can find more information at https://shopify.dev/docs/apps/launch/deployment/deploy-web-app/deploy-to-hosting-service#step-4-set-up-environment-variables`\n        : `Invalid appUrl configuration '${appConfig.appUrl}', please provide a valid URL.`;\n    throw new ShopifyError(message);\n  }\n\n  /* eslint-disable no-process-env */\n  if (appUrl.hostname === 'localhost' && !appUrl.port && process.env.PORT) {\n    appUrl.port = process.env.PORT;\n  }\n  /* eslint-enable no-process-env */\n  appConfig.appUrl = appUrl.origin;\n\n  let userAgentPrefix = `Shopify React Router Library v${SHOPIFY_REACT_ROUTER_LIBRARY_VERSION}`;\n  if (appConfig.userAgentPrefix) {\n    userAgentPrefix = `${appConfig.userAgentPrefix} | ${userAgentPrefix}`;\n  }\n\n  return shopifyApi({\n    ...appConfig,\n    hostName: appUrl.host,\n    hostScheme: appUrl.protocol.replace(':', '') as 'http' | 'https',\n    userAgentPrefix,\n    isEmbeddedApp: true,\n    isCustomStoreApp: appConfig.distribution === AppDistribution.ShopifyAdmin,\n    billing: appConfig.billing,\n    future: {\n      unstable_managedPricingSupport: true,\n    },\n    _logDisabledFutureFlags: false,\n  });\n}\n\nfunction deriveConfig<Storage extends SessionStorage>(\n  appConfig: AppConfigArg,\n  apiConfig: ApiConfig,\n): AppConfig<Storage> {\n  if (\n    !appConfig.sessionStorage &&\n    appConfig.distribution !== AppDistribution.ShopifyAdmin\n  ) {\n    throw new ShopifyError(\n      'Please provide a valid session storage. Refer to https://github.com/Shopify/shopify-app-js/blob/main/README.md#session-storage-options for options.',\n    );\n  }\n\n  const authPathPrefix = appConfig.authPathPrefix || '/auth';\n  appConfig.distribution = appConfig.distribution ?? AppDistribution.AppStore;\n\n  return {\n    ...appConfig,\n    ...apiConfig,\n    billing: appConfig.billing,\n    scopes: apiConfig.scopes,\n    idempotentPromiseHandler: new IdempotentPromiseHandler(),\n    canUseLoginForm: appConfig.distribution !== AppDistribution.ShopifyAdmin,\n    useOnlineTokens: appConfig.useOnlineTokens ?? false,\n    hooks: appConfig.hooks ?? {},\n    sessionStorage: appConfig.sessionStorage as Storage,\n    future: appConfig.future ?? {},\n    auth: {\n      path: authPathPrefix,\n      callbackPath: `${authPathPrefix}/callback`,\n      patchSessionTokenPath: `${authPathPrefix}/session-token`,\n      exitIframePath: `${authPathPrefix}/exit-iframe`,\n      loginPath: `${authPathPrefix}/login`,\n    },\n    distribution: appConfig.distribution,\n  };\n}\n", "import '@shopify/shopify-api/adapters/web-api';\nimport {setAbstractRuntimeString} from '@shopify/shopify-api/runtime';\n\nsetAbstractRuntimeString(() => {\n  return `React Router`;\n});\n\nexport {\n  LogSeverity,\n  DeliveryMethod,\n  BillingInterval,\n  BillingReplacementBehavior,\n  ApiVersion,\n  Session,\n} from '@shopify/shopify-api';\n\nexport type {JwtPayload} from '@shopify/shopify-api';\n\nexport type * from './types-contexts';\nexport type {ShopifyApp, LoginError} from './types';\nexport {LoginErrorType, AppDistribution} from './types';\nexport {boundary} from './boundary';\nexport {shopifyApp} from './shopify-app';\nexport * from './errors';\n"],
  "mappings": "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",
  "names": ["_jsx", "isEmbeddedRequest", "params", "SESSION_TOKEN_PARAM", "redirect", "reactRouterRedirect", "reactRouterRedirect", "admin", "shop", "sessionId", "warningFunction", "context", "searchParams"]
}
